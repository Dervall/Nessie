#include "PPU.h"
#include <memory.h>
#include "NES.h"
#include "Emulator.h"
#include "CPU.h"

#define SLEndFrame 262

const	unsigned char	ReverseCHR[256] =
{
	0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
	0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
	0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
	0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
	0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
	0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
	0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
	0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
	0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
	0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
	0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
	0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
	0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
	0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
	0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
	0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF
};

const	unsigned char	attribLoc[256] =
{
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
	0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
	0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
	0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
	0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
	0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
	0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F
};
const	unsigned long	attribBits[4] =
{
	0x00000000,0x04040404,0x08080808,0x0C0C0C0C
};

const	unsigned char	attribShift[128] =
{
	0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,
	4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6,4,4,6,6
};

const	unsigned long	CHRLoBit[16] =
{
	0x00000000,0x00000001,0x00000100,0x00000101,0x00010000,0x00010001,0x00010100,0x00010101,
	0x01000000,0x01000001,0x01000100,0x01000101,0x01010000,0x01010001,0x01010100,0x01010101
};
const	unsigned long	CHRHiBit[16] =
{
	0x00000000,0x00000002,0x00000200,0x00000202,0x00020000,0x00020002,0x00020200,0x00020202,
	0x02000000,0x02000002,0x02000200,0x02000202,0x02020000,0x02020002,0x02020200,0x02020202
};

PPU::PPU(CPU* p, Emulator* pEmu) {
	pCpu = p;
	pEmulator = pEmu;
}

PPU::~PPU() {
}

void PPU::reset() {
	// Zero the registers
	memset(reg, 0, 8);
	
	// Reset the register write toggle flag
	regWriteToggle = 1;
	intX = 0;
	ppuAddr = 0;
	intReg = 0;
}

BYTE PPU::readStatus() {
	// Reading clears the vblank flag
	// Erm.. if that were to happen then things would not work that well would they
	// since all games wait for the damn vblank flag to be returned...
	//reg[PPUSTATUS & 7] &= 0x7F;
	return reg[PPUSTATUS & 7];
}

BYTE PPU::readOAMAddr() {
	return reg[OAMADDR & 7];
}

BYTE PPU::readOAMData() {
	// TODO: Should this increase the OAMADDR register? I dont know	
	return readOAMMem(reg[OAMADDR & 7]);
}

BYTE PPU::readPPUData() {
	static BYTE vramReadBuffer;	// Garbage from the start!!

	BYTE ret = vramReadBuffer;
	WORD a = ppuAddr;

	// Increment the address by 1 or 32 depending on the
	// status of bit 2 of reg $2000.
	(reg[PPUCTRL & 7] & 4) ? (ppuAddr += 32) : ppuAddr++;

	if (ppuAddr >= 0 && ppuAddr < 0x3F00) {
		// Read the byte into the VRAM buffer.
		vramReadBuffer = readPPUMem(a);

		return ret;
	} else {
		// Mystery "feature" of the PPU
		vramReadBuffer = readPPUMem(a - 0x1000);
		return readPPUMem(a);
	}
}

void PPU::writeCtrlReg( BYTE value ) {
	reg[PPUCTRL & 7] = value;
	intReg &= 0x73FF;
	intReg |= (value & 3) << 10;
}

void PPU::writeMask( BYTE value ) {
	reg[PPUMASK & 7] = value;
}

void PPU::writeOAMAddr( BYTE value ) {
	reg[OAMADDR & 7] = value;
}

void PPU::writeOAMData( BYTE value ) {
	writeOAMMem(reg[OAMADDR & 7], value); 
}

void PPU::writeScroll( BYTE value ) {
	// The second write is the vertical scroll, the
	// first write is the horizontal scroll.
	if (regWriteToggle) {
		intReg &= 0x7FE0;
		intReg |= (value & 0xF8) >> 3;
		intX = value & 7;
	} else {
		intReg &= 0x0C1F;
		intReg |= (value & 0x07) << 12;
		intReg |= (value & 0xF8) << 2;
	}

	// Toggle to indicate that we are on the second write.
	regWriteToggle ^= 1;
}

void PPU::writePPUAddr( BYTE value ) {
	if (regWriteToggle) {
		intReg &= 0x00FF;
		intReg |= (value & 0x37) << 8;
	} else {
		intReg &= 0x7F00;
		intReg |= value;
		ppuAddr = intReg;
	}

	// Toggle to indicate that we are on the second write.
	regWriteToggle ^= 1;
}

void PPU::writePPUData( BYTE value ) {
	// Write the byte to video memory.
	writePPUMem(ppuAddr, value);

	// Increment the address by 1 or 32 depending on the
	// status of bit 2 of reg $2000.
	(reg[PPUCTRL & 7] & 4) ? (ppuAddr += 32) : ppuAddr++;
}

void PPU::writeOAMMem( BYTE address, BYTE data ) {
	oamData[address] = data;
}

BYTE PPU::readOAMMem( BYTE address ) {
	return oamData[address];
}

void PPU::writePPUMem( WORD address, BYTE data ) {
	BYTE* p = getVramPtr(address);
	*p = data; // Screw illegal writes right now
}

BYTE PPU::readPPUMem( WORD address ) {
	BYTE* p = getVramPtr(address);
	return *p;
}

BYTE* PPU::getVramPtr(WORD address) {
	// Data is completely mirrored after 0x3FFF so 
	// strip away anything greater than that.
	address &= 0x3FFF;

	if (address < 0x1000) {
		// This leads to the pattern tables
		return pPatternTable1 + address;
	} else if (address < 0x2000) {
		// This leads to the pattern tables
		return pPatternTable2 + address - 0x1000;
	} else if (address < 0x3EFF) {
		// Account for the possible mirroring of the naming tables
		if (address >= 0x3000) {
			address -= 0x1000;
		}
		address -= 0x2000;
		int nameTableIndex = address / 0x400;
		int nameTableOffset = address % 0x400;
		return apNameTable[nameTableIndex] + nameTableOffset;
	} else {
		return palette + ( address & 0x3F00 );
	}
}

void PPU::setupNameTables( int mirror ) {
	// Initialize the pointers to the name tables depending on the
	// mirroring of the ROM. Bit 1 of the rom header offset 6
	// is 1 for vertical mirroring and 0 for horizontal mirroring.		
	if (mirror)
	{
		// For vertical mirroring, name tables 0 and 2 point to
		// the first name table and name tables 1 and 3 point to
		// the second name table.
		apNameTable[0] = &aNameTableMem[0];
		apNameTable[1] = &aNameTableMem[0x400];
		apNameTable[2] = &aNameTableMem[0];
		apNameTable[3] = &aNameTableMem[0x400];
	}
	else
	{
		// For horizontal mirroring, name tables 0 and 1 point to
		// the first name table and name tables 2 and 3 point to
		// the second name table.
		apNameTable[0] = &aNameTableMem[0];
		apNameTable[1] = &aNameTableMem[0];
		apNameTable[2] = &aNameTableMem[0x400];
		apNameTable[3] = &aNameTableMem[0x400];
	}
}

void PPU::setPatternTable1( BYTE* p ) {
	pPatternTable1 = p;
}
void PPU::setPatternTable2( BYTE* p ) {
	pPatternTable2 = p;
}

void PPU::setVblankFlag() {
	reg[PPUSTATUS & 7] |= 1 << 7;
}

void PPU::clearVblankFlag() {
	reg[PPUSTATUS & 7] &= 0x7F;
}

void PPU::renderScanline(int scanline, unsigned int* pOut) {
	// First find out which name table we are using
	// it is found in 0x2000 lower two bits
	int nt = reg[PPUCTRL & 7] & 3;

	BYTE* pNameTable = apNameTable[nt];
	
	// Now get the pointer to the attribute table, it is found 0x3C0 after the
	// name table address
	BYTE* pAttributeTable = pNameTable + 0x3C0;

	// Find out which pattern table we are using
	// this is found in PPUCTRL >> 4 (one bit);
	int pt = (reg[PPUCTRL & 7] & 0x10) >> 4;
	BYTE* pPatternTable = pt ? pPatternTable1 : pPatternTable2;

	// Calculate beginning tile number
	// Scanline / 8 * 32 + Hscroll / 8;
	WORD startTile = ((scanline >> 3) << 5);
	int tileNum = startTile + ( intX >> 3);

	BYTE* pTileAddr = pNameTable + tileNum;
	BYTE* pTileDataOffset = pPatternTable + *pTileAddr;

//	BYTE tileData1 = 

	for (int i = 0; i < 256; ++i ) {
		BYTE b = *(pTileAddr + ( i >> 3));
		b << 4;
		*pOut++ = ((unsigned int)b) << 16 | b;
	}
}